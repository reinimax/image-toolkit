{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IMAGE TOOLKIT","text":""},{"location":"#video-demo","title":"Video Demo:","text":""},{"location":"#description","title":"Description:","text":"<p>Image toolkit  is a service for basic image manipulation. It features a website where the user can upload an image for processing, as well as an API, powered by Flask. Image processing uses Pillow under the hood.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation is hosted on Github</li> <li>Backend and Frontend are hosted on Python Anywhere</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li>Set up virtual environment: <code>python3 -m venv .venv</code></li> <li>Activate virtual environment: <code>. .venv/bin/activate</code></li> <li>Install dependencies: <code>python -m pip install -r requirements.txt</code></li> </ol> <p>Note: You can exit the virtual environment by typing <code>deactivate</code>. Learn more about virtual environments and package installation.</p>"},{"location":"#building-and-serving-the-docs","title":"Building and serving the docs <p>The documentation for this project is automatically generated using mkdocs and pdoc. It consists of this README file and the documentation  in the <code>operations.py</code> and <code>formats.py</code> files.</p> <p>You can serve the documentation locally by running <code>mkdocs serve</code>. Running <code>mkdocs build</code> will rebuild the docs (inside the <code>docs</code> folder). Note that if you make changes to one of the Python files, you need to run <code>./make.py</code> before you build or serve, so that mkdocs picks up the latest changes.</p>","text":""},{"location":"#run-the-service-locally","title":"Run the service locally","text":"<p>Activate the virtual environment and type <code>flask run</code>. If you want to use the frontend locally, you need to set up an additional local server  (for development, I used the excellent LiveServer VSCode extension) and change the  <code>BASE_URL</code>constant in <code>frontend/script.js</code> to point to Flasks local server.</p>"},{"location":"#self-host-the-service","title":"(Self-) Host the service","text":"<p>Refer to Flask's documentation for deploying to production. Again, for the frontend, you may need an additional server/hosting, or to configure the WSGI server to serve the contents of the <code>frontend</code> directory statically. I use Python anywhere to host the demo.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#via-the-web-interface-upload-form","title":"via the web-interface (upload form)  <p>I hope, the web-interface is pretty self-explanatory. First, upload an image via the upload widget at the bottom of the page. Then configure the operations you want to perform. Except for the filters, you need to check the \"Apply\" checkbox next to the operation, otherwise it won't be performed. When you're done, hit the \"Submit\" button. If you omit a required field or forget to upload an image in the first place, an error message will be displayed that should be pretty easy to notice.</p> <p>After submitting, the text of the submit button will change to \"In progress ...\". After it changed back (and for small images it might be so fast that you don't even notice the button text changing and changing back), the image is ready and you should see the updated image in the preview. You can view or download the processed image via the buttons below the image (due to the frontend styling, big images won't be displayed full-size in the UI. If you want to view the image full-size, the \"View\" button is your friend).</p> <p>Note that the web-interface implements most, but not all functionality of the API. This is intentional to further showcase the decoupled nature of this project.</p>","text":""},{"location":"#via-the-api","title":"via the API <p>There is one API endpoint, <code>/image-process</code>, which expects a <code>POST</code> request with a <code>JSON</code> payload.</p> <p>Except the obligatory <code>Content-Type: application/json</code>, no additional headers and no authentication are required.</p> <p>The <code>JSON</code> payload has two mandatory fields:</p> <ul> <li><code>original_image</code>: base64-encoded image.</li> <li><code>operations</code>: array of objects that define the operations to be performed on the image. Operations will be performed in order. If an invalid operation is given, or a valid operation fails, the other operations will still be performed.</li> </ul> <p>An <code>operation</code> object itself consists of a mandatory <code>name</code> field which specifies the operation that should be performed. The name is the same as the name of the processing function that will be called to do the work.</p> <p>Optionally, each operation accepts arguments that specify how the image should be processed, e.g. a width and/or height for resizing an image. Dimensions like width or height can be given to the API in different ways: Generally, it will accept units of pixels and percent. If the unit is pixels, it can be omitted, since this is assumed as the default. These would all be valid arguments:</p> <pre><code>\"width\": \"300px\"\n\"width\": \"300\" // 300px, as above\n\"width\": 300\n\"width\": 300.0 // this works too, but is considered bad practice\n\"width\": \"50%\" // 50 percent\n</code></pre> <p>Optionally, within the key <code>return_as</code>, you can also provide a format in which the image should be returned, along with some options for image quality. Refer to the Supported formats page for more details. If <code>return_as</code> is ommitted or contains an invalid format, the image will be returned in the same format in which it was submitted.</p> <p>A complete payload might look like this:</p> <pre><code>{\n    \"operations\": [\n        {\n            \"name\": \"rotate\",\n            \"degrees\": 180\n        },\n        {\n            \"name\": \"resize\",\n            \"width\": \"50%\",\n        },\n        // ... any other operations you like to perform.\n    ],\n    // optional return format and options\n    \"return_as\": {\n        \"format\": \"webp\",\n        \"quality\": 80\n    },\n    \"original_image\": \"...\" // base64-encoded image\n}\n</code></pre>","text":""},{"location":"#api-response","title":"API response","text":"<p>A successful response from the API will look like this:</p> <pre><code>{\n    \"metadata\": {\n        \"format\": \"webp\", // format of the processed image\n        // width and height of the processed image\n        \"height\": 374,\n        \"width\": 300\n    },\n    \"processed_image\": \"...\" // base64-encoded image\n}\n</code></pre> <p>If you get back the original image, or some operations were not performed, this probably means you provided invalid/incomplete parameters to some operation(s). If you found a bug, feel free to open an issue.</p> <p>If you really messed up the <code>JSON</code> payload or did not provide a correctly encoded image, you will get an error response instead:</p> <pre><code>{\n    \"error\": \"No image provided.\" // The error message will try to explain what caused the error.\n}\n</code></pre> <p>However, I tried to design this API pretty robust and forgiving, so (hopefully) what you'll see more often is just some operation not being performed if you forgot an argument or mistyped something.</p> <p>You can look up the available processing functions and the arguments they expect in the API documentation (ignore the <code>image</code> argument, as this will be passed in automatically).</p>"},{"location":"#accepted-file-formats","title":"Accepted file formats","text":"<p>The supported formats page lists the formats that the API is guaranteed to accept and return. Other image formats may work as input. Refer to the Pillow documentation to see which formats may work.</p>"},{"location":"#a-short-tour-of-the-repo","title":"A short tour of the repo","text":"<p>This repository consists of 4 main parts:</p>"},{"location":"#the-backendapi","title":"The backend/API","text":"<p>This is a flask application, consisting of these files:</p> <ul> <li><code>app.py</code>defines the routing and interface of the API.</li> <li><code>operations.py</code> defines the available image manipulation operations.</li> <li><code>formats.py</code> defines the supported formats that the API can convert images into.</li> <li><code>helpers.py</code> defines some helper functions.</li> <li><code>requirements.txt</code> defines the libraries used by the application.</li> </ul>"},{"location":"#the-frontend","title":"The frontend","text":"<p>The frontend consists of static HTML, CSS and JavaScript files, which can be found inside the <code>frontend</code> directory:</p> <ul> <li><code>index.html</code> defines the markup of the web-interface</li> <li><code>style.css</code> contains the styling</li> <li><code>script.js</code> handles image upload, download and preview, prepares the JSON payload for and makes the request to the API</li> </ul>"},{"location":"#the-documentation","title":"The documentation","text":"<p>The documentation is automatically generated from the README file and the docstrings from the source code of the API. It is located in the <code>docs</code> directory.</p>"},{"location":"#tooling-for-the-documentation","title":"Tooling for the documentation:","text":"<p>There are a number of files dedicated to auto-generating documentation and integrating pdoc with mkdocs:</p> <ul> <li><code>mkdocs.yml</code> is the configuration file for creating a static site containing the documentation.</li> <li><code>make.py</code> is a script that generates <code>pdoc</code> documentation and moves it to a directory and format where it can be picked off by <code>mkdocs</code>.</li> <li>The <code>pdoc-template</code> folder contains a template override and styling for <code>pdoc</code>, so that it better integrates with the generated <code>mkdocs</code>.</li> <li>The <code>mk-docs</code>folder contains an <code>index.md</code> file that links the README into the generated documentation and <code>custom.js</code> that does some cosmetic changes to better integrate the documentation generated by <code>pdoc</code>. <code>hooks.py</code> takes care of copying the screenshot from the projects root directory to the docs directory.</li> </ul>"},{"location":"#design-decisions","title":"Design decisions","text":"<ul> <li>I decided to create just one API-endpoint and make the user provide the wanted operations as JSON payload. This is more user-friendly, because it lets you chain operations together in one single request.</li> <li>I tried out autogenerating API documentation using flaskapi and the OpenAPI spec, which is awesome in principle, but didn't convince me in the context of this project. There is only one API endpoint, which takes a lot of parameters. OpenAPI is great if you have a lot of small endpoints and methods, but that's not the case here. What I really needed was to document the single image manipulation operations. At the end, I decided to use pdoc, an easy to use library that generates pretty neat documentation and integrate it with mkdocs, linking this README file to the generated documentations index file using pymdown-extensions.</li> <li>In a similar vein, I looked into APIflask which has some neat features. But in the end I decided to stick with vanilla Flask and making some adoptions manually (e.g. making sure error responses are always sent as JSON instead of text/html). The reason is, I wanted to keep things simple and avoid the application being overloaded with features that I don't really use, especially since I decided against going with the OpenAPI approach.</li> <li>For implementing different formats in which the image can be returned, I decided to follow an approach very similar to the one for operations: Create a new file that defines saving functions and dynamically call them if a valid image format was submitted. I tried first a simpler approach with dynamically passing arguments to the <code>save</code> function of the <code>Image</code> class. This is less code, but I decided against it for 2 reasons:  First, defining custom save functions allows for better auto-generated documentation.  And second, perhaps more important, it allows for providing default arguments that are different from the ones provided by Pillow, and for additional validation. The chosen approach is more verbose, but I find it also more robust and explicit.</li> <li>The frontend is deliberately rather simplistic and minimally styled. The focus of this project is the API and the frontend serves more as a demo and a handy tool if you just want to quickly upload and image. The UI works and is pretty usable, but of course much could be improved in terms of UI/UX. For that, it would be a good idea to use libraries or even a framework, but again, this would make the frontend more complex and exceed the scope of this project. </li> <li>Essentially, the web-interface is one big form, and you have to check the \"Apply\"-checkbox for each operation that you want to perform. Splitting it up into smaller forms, each with a submit button, would be a more user-friendly alternative (you really forget to check that checkbox pretty easily). However, I decided against that approach, because I wanted to showcase the possibility of chaining operations on the frontend too.</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Huge thanks to HuggingChat for providing suggestions and feeback regarding some initial design decisions (link to the chat) and for help with debugging some stuff.</li> <li>Huge thanks also to Python anywhere which provides a free hosting tier, on which this project is hosted.</li> <li>This project would not have been possible without some amazing libraries. See below for a list of projects this project relies on.</li> </ul>"},{"location":"#powerd-by","title":"Powerd by","text":"<ul> <li>Flask: API/backend</li> <li>Flask-Cors: CORS support</li> <li>Pillow: Image processing</li> <li>pdoc: Generate documentation from Python doc strings</li> <li>mkdocs: Static site generator for the documentation</li> <li>Material for MkDocs: Documentation theme</li> <li>PyMdown Extensions</li> <li>MkDocs - Open in a new tab plugin</li> </ul>"},{"location":"api/","title":"Index","text":""},{"location":"api/formats/","title":"Supported formats","text":"formats API documentation API Documentation <ul> <li> jpeg </li> <li> png </li> <li> webp </li> </ul>              built with pdoc  formats     <p>This file defines available formats for returning a processed image.  New functions added here will be automatically picked up when the  function is added to the ALLOWED_FORMATS dictionary.</p> <p>Function arguments will be automatically passed when the function is called,  if they were given via the API. The keys provided in the <code>return_as</code> object must  match the parameter names of the Python function. For example, giving this JSON  to the API</p> <pre><code>\"return_as\": {\n        \"format\": \"webp\",\n        \"quality\": 20\n    }\n</code></pre> <p>would result in this function call: <code>webp(image, buffer, quality=20)</code>.</p> <p>Note that each function automatically gets an image object of class <code>PIL.Image.Image</code>  and a buffer object of class <code>io.BytesIO</code> passed as the first two parameters.  The image should be saved to this buffer.</p> View Source <pre> 1\"\"\"\n 2This file defines available formats for returning a processed image. \n 3New functions added here will be automatically picked up when the \n 4function is added to the ALLOWED_FORMATS dictionary.\n 5\n 6Function arguments will be automatically passed when the function is called, \n 7if they were given via the API. The keys provided in the `return_as` object must \n 8match the parameter names of the Python function. For example, giving this JSON \n 9to the API\n10```\n11\"return_as\": {\n12        \"format\": \"webp\",\n13        \"quality\": 20\n14    }\n15```\n16would result in this function call: `webp(image, buffer, quality=20)`.\n17\n18Note that each function automatically gets an image object of class `PIL.Image.Image` \n19and a buffer object of class `io.BytesIO` passed as the first two parameters. \n20The image should be saved to this buffer.\n21\"\"\"\n22\n23from io import BytesIO\n24from PIL import Image\n25\n26def jpeg(image:Image.Image, buffer:BytesIO, quality=75) -&gt; None:\n27    \"\"\"#Convert image to jpeg format.\n28\n29    **Parameters:**\n30    - image (Image): PIL image object\n31    - buffer (BytesIO): Buffer to which the image is written\n32    - quality: Quality of the image. Shoulb be between 0 (lowest quality) and 95 (highest quality).\n33    \"\"\"\n34    # If we get a string or float, convert to int. Pillow is picky and accepty only an int here.\n35    if isinstance(quality, str) or isinstance(quality, float):\n36        try:\n37            quality = int(quality)\n38        except:\n39            quality = 75\n40    # Make sure quality is within the supported range\n41    if quality &lt; 0 or quality &gt; 95:\n42        quality = 75\n43    image.save(buffer, format=\"jpeg\", quality=quality)\n44\n45\n46def png(image:Image.Image, buffer:BytesIO, compress_level=6, optimize:bool=False) -&gt; None:\n47    \"\"\"#Convert image to png format.\n48\n49    **Parameters:**\n50    - image (Image): PIL image object\n51    - buffer (BytesIO): Buffer to which the image is written\n52    - compress_level: Must be between 0 and 9. 0 means no compression, 9 means maximum compression.\n53    If `optimize`is true, `compress_level` is always 9.\n54    - optimize (bool): If true, the image will be made as small as possible.\n55    \"\"\"\n56    if isinstance(compress_level, str) or isinstance(compress_level, float):\n57        try:\n58            compress_level = int(compress_level)\n59        except:\n60            compress_level = 6\n61    if compress_level &lt; 0 or compress_level &gt; 9:\n62        compress_level = 6\n63    if not isinstance(optimize, bool):\n64        optimize = False\n65    image.save(buffer, format=\"png\", compress_level=compress_level, optimize=optimize)\n66\n67\n68def webp(image:Image.Image, buffer:BytesIO, quality=80, lossless:bool=False) -&gt; None:\n69    \"\"\"#Convert image to webp format.\n70\n71    **Parameters:**\n72    - image (Image): PIL image object\n73    - buffer (BytesIO): Buffer to which the image is written\n74    - quality: Quality of the image. Shoulb be between 0 (lowest quality) and 100 (highest quality).\n75    If `lossless`is true, this will instead determine the speed of saving the image (0 = fastest, 100 = slowest).\n76    - lossless (bool): Whether to use lossless compression.\n77    \"\"\"\n78    # If we get a string, try to convert to float\n79    if isinstance(quality, str):\n80        try:\n81            quality = float(quality)\n82        except:\n83            # If an invalid argument was provided, use the default instead.\n84            quality = 80\n85    # Make sure quality is within the supported range\n86    if quality &lt; 0 or quality &gt; 100:\n87        quality = 80\n88    if not isinstance(lossless, bool):\n89        lossless = False\n90    image.save(buffer, format=\"webp\", quality=quality, lossless=lossless)\n91\n92\n93ALLOWED_FORMATS = {\n94    \"jpeg\": jpeg,\n95    \"png\": png,\n96    \"webp\": webp\n97}\n98\"\"\"@private\"\"\"\n</pre> def jpeg(image: PIL.Image.Image, buffer: _io.BytesIO, quality=75) -&gt; None: View Source <pre>27def jpeg(image:Image.Image, buffer:BytesIO, quality=75) -&gt; None:\n28    \"\"\"#Convert image to jpeg format.\n29\n30    **Parameters:**\n31    - image (Image): PIL image object\n32    - buffer (BytesIO): Buffer to which the image is written\n33    - quality: Quality of the image. Shoulb be between 0 (lowest quality) and 95 (highest quality).\n34    \"\"\"\n35    # If we get a string or float, convert to int. Pillow is picky and accepty only an int here.\n36    if isinstance(quality, str) or isinstance(quality, float):\n37        try:\n38            quality = int(quality)\n39        except:\n40            quality = 75\n41    # Make sure quality is within the supported range\n42    if quality &lt; 0 or quality &gt; 95:\n43        quality = 75\n44    image.save(buffer, format=\"jpeg\", quality=quality)\n</pre> def png( image: PIL.Image.Image, buffer: _io.BytesIO, compress_level=6, optimize: bool = False) -&gt; None: View Source <pre>47def png(image:Image.Image, buffer:BytesIO, compress_level=6, optimize:bool=False) -&gt; None:\n48    \"\"\"#Convert image to png format.\n49\n50    **Parameters:**\n51    - image (Image): PIL image object\n52    - buffer (BytesIO): Buffer to which the image is written\n53    - compress_level: Must be between 0 and 9. 0 means no compression, 9 means maximum compression.\n54    If `optimize`is true, `compress_level` is always 9.\n55    - optimize (bool): If true, the image will be made as small as possible.\n56    \"\"\"\n57    if isinstance(compress_level, str) or isinstance(compress_level, float):\n58        try:\n59            compress_level = int(compress_level)\n60        except:\n61            compress_level = 6\n62    if compress_level &lt; 0 or compress_level &gt; 9:\n63        compress_level = 6\n64    if not isinstance(optimize, bool):\n65        optimize = False\n66    image.save(buffer, format=\"png\", compress_level=compress_level, optimize=optimize)\n</pre> def webp( image: PIL.Image.Image, buffer: _io.BytesIO, quality=80, lossless: bool = False) -&gt; None: View Source <pre>69def webp(image:Image.Image, buffer:BytesIO, quality=80, lossless:bool=False) -&gt; None:\n70    \"\"\"#Convert image to webp format.\n71\n72    **Parameters:**\n73    - image (Image): PIL image object\n74    - buffer (BytesIO): Buffer to which the image is written\n75    - quality: Quality of the image. Shoulb be between 0 (lowest quality) and 100 (highest quality).\n76    If `lossless`is true, this will instead determine the speed of saving the image (0 = fastest, 100 = slowest).\n77    - lossless (bool): Whether to use lossless compression.\n78    \"\"\"\n79    # If we get a string, try to convert to float\n80    if isinstance(quality, str):\n81        try:\n82            quality = float(quality)\n83        except:\n84            # If an invalid argument was provided, use the default instead.\n85            quality = 80\n86    # Make sure quality is within the supported range\n87    if quality &lt; 0 or quality &gt; 100:\n88        quality = 80\n89    if not isinstance(lossless, bool):\n90        lossless = False\n91    image.save(buffer, format=\"webp\", quality=quality, lossless=lossless)\n</pre>"},{"location":"api/formats/#convert-image-to-jpeg-format","title":"Convert image to jpeg format.","text":"<p>Parameters:</p> <ul> <li>image (Image): PIL image object</li> <li>buffer (BytesIO): Buffer to which the image is written</li> <li>quality: Quality of the image. Shoulb be between 0 (lowest quality) and 95 (highest quality).</li> </ul>"},{"location":"api/formats/#convert-image-to-png-format","title":"Convert image to png format.","text":"<p>Parameters:</p> <ul> <li>image (Image): PIL image object</li> <li>buffer (BytesIO): Buffer to which the image is written</li> <li>compress_level: Must be between 0 and 9. 0 means no compression, 9 means maximum compression. If <code>optimize</code>is true, <code>compress_level</code> is always 9.</li> <li>optimize (bool): If true, the image will be made as small as possible.</li> </ul>"},{"location":"api/formats/#convert-image-to-webp-format","title":"Convert image to webp format.","text":"<p>Parameters:</p> <ul> <li>image (Image): PIL image object</li> <li>buffer (BytesIO): Buffer to which the image is written</li> <li>quality: Quality of the image. Shoulb be between 0 (lowest quality) and 100 (highest quality). If <code>lossless</code>is true, this will instead determine the speed of saving the image (0 = fastest, 100 = slowest).</li> <li>lossless (bool): Whether to use lossless compression.</li> </ul>"},{"location":"api/operations/","title":"Processing functions","text":"operations API documentation API Documentation <ul> <li> blur </li> <li> greyscale </li> <li> posterize </li> <li> resize </li> <li> rotate </li> <li> sharpen </li> </ul>              built with pdoc  operations     <p>This file defines image manipulation operations that are callable via the API. New functions added here will be automatically picked up when the function is  added to the <code>ALLOWED_OPERATIONS</code> dictionary.</p> <p>Function arguments will be automatically passed when the function is called,  if they were given via the API. The keys provided in the <code>operations</code> object  must match the parameter names of the Python function. For example, giving  this JSON to the API</p> <pre><code>\"operations\": [\n    {\n        \"name\": \"resize\",\n        \"width\": \"300px\"\n    }\n]\n</code></pre> <p>would result in this function call: <code>resize(image, width=\"300px\")</code>.</p> <p>Note that every image manipulation function must take an object of class  <code>PIL.Image.Image</code> as its first parameter, which will always be automatically  passed to the function.</p> View Source <pre>  1\"\"\"\n  2This file defines image manipulation operations that are callable via the API.\n  3New functions added here will be automatically picked up when the function is \n  4added to the `ALLOWED_OPERATIONS` dictionary.\n  5\n  6Function arguments will be automatically passed when the function is called, \n  7if they were given via the API. The keys provided in the `operations` object \n  8must match the parameter names of the Python function. For example, giving \n  9this JSON to the API\n 10```\n 11\"operations\": [\n 12    {\n 13        \"name\": \"resize\",\n 14        \"width\": \"300px\"\n 15    }\n 16]\n 17```\n 18would result in this function call: `resize(image, width=\"300px\")`.\n 19\n 20Note that every image manipulation function must take an object of class \n 21`PIL.Image.Image` as its first parameter, which will always be automatically \n 22passed to the function.\n 23\"\"\"\n 24\n 25from PIL import Image, ImageOps, ImageFilter\n 26from helpers import Unit, parse_dimension\n 27\n 28def blur(image:Image.Image) -&gt; Image.Image:\n 29    \"\"\"#Apply a blur filter to the image\n 30    \n 31    **Parameters:**\n 32    - image (Image): PIL image object\n 33\n 34    **Returns**:\n 35    PIL Image object\n 36    \"\"\"\n 37    return image.filter(filter=ImageFilter.BLUR)\n 38\n 39\n 40def greyscale(image:Image.Image) -&gt; Image.Image:\n 41    \"\"\"#Apply a greyscale filter to the image\n 42    \n 43    **Parameters:**\n 44    - image (Image): PIL image object\n 45\n 46    **Returns**:\n 47    PIL Image object\n 48    \"\"\"\n 49    return ImageOps.grayscale(image)\n 50\n 51\n 52def posterize(image:Image.Image, intensity=2) -&gt; Image.Image:\n 53    \"\"\"#Apply a posterize filter to the image\n 54    \n 55    **Parameters:**\n 56    - image (Image): PIL image object\n 57    - intensity: How strong the posterize effect should be. \n 58    Must be an integer between 1 (strongest) and 8 (weakest).\n 59\n 60    **Description:**\n 61    This filter will reduce the colors of the image, creating a poster-like effect.\n 62\n 63    **Returns**:\n 64    PIL Image object\n 65    \"\"\"\n 66    if isinstance(intensity, str) or isinstance(intensity, float):\n 67        try:\n 68            intensity = int(intensity)\n 69        except:\n 70            intensity = 2\n 71    if intensity &lt; 1 or intensity &gt; 8:\n 72        intensity = 2\n 73    return ImageOps.posterize(image, intensity)\n 74\n 75\n 76def resize(image:Image.Image, width:str=None, height:str=None) -&gt; Image.Image:\n 77    \"\"\"#Resize the image to the provided dimensions\n 78    \n 79    **Parameters:**\n 80    - image (Image): PIL image object\n 81    - width (str): Width to which the image should be resized\n 82    - height (str): Height to which the image should be resized\n 83\n 84    **Description:**  \n 85    If both width and height are given, the image will be resized \n 86    regardless of aspect ratio.  \n 87    If either width or height are given, the image will be scaled to \n 88    that dimension and aspect ratio will be maintained.  \n 89    If the given dimension(s) are bigger than the original image, or \n 90    neither width nor height are provided, the original image will be \n 91    returned without resizing.\n 92\n 93    **Returns**:\n 94    PIL Image object\n 95    \"\"\"\n 96    # If no dimensions were provided, return the original image.\n 97    if not width and not height:\n 98        return image\n 99    \n100    # Get original image dimensions\n101    orig_w, orig_h = image.size\n102\n103    if width:\n104        width, unit = parse_dimension(width)\n105        if unit == Unit.PERCENT:\n106            width = int(orig_w * width / 100)\n107\n108    if height:\n109        height, unit = parse_dimension(height)\n110        if unit == Unit.PERCENT:\n111            height = int(orig_h * height / 100)\n112\n113    # Scale the dimension that was not provided\n114    if not height:\n115        # Calculate by how much the image scales down\n116        scale = width / orig_w\n117        # Scale the height accordingly\n118        height = int(orig_h * scale)\n119    elif not width:\n120        scale = height / orig_h\n121        width = int(orig_w * scale)\n122\n123    # Make sure the given dimensions are greater than 0 and don't exceed the original image.\n124    if width &lt;= 0 or height &lt;= 0 or width &gt; orig_w or height &gt; orig_h:\n125        return image\n126    \n127    return image.resize((width, height))\n128\n129\n130def rotate(image:Image.Image, degrees, expand:bool=True, clockwise:bool=False) -&gt; Image.Image:\n131    \"\"\"#Rotate the image by the provided degrees\n132    \n133    **Parameters:**\n134    - image (Image): PIL image object\n135    - degrees (int|float|str): Amount of degrees by which to rotate the image\n136    - expand (bool): Whether the image dimensions should expand so that the \n137    resulting image contains all of the original image. If set to False, the \n138    image will remain the same size and parts that would be \"outside\" the image \n139    due to roation will be cut. For rotating by 90 and 270 degrees, leave this \n140    setting set to True, since this will allow width and height of the image to \n141    switch without producing a border\n142    - clockwise (bool): Set to True for clockwise rotation. Per default, rotation \n143    is counter-clockwise\n144\n145    **Description:**  \n146    Rotate the image counter-clockwise by the provided degrees.\n147\n148    **Returns**:\n149    PIL Image object\n150    \"\"\"\n151    # If we get a string, try to convert to float\n152    if isinstance(degrees, str):\n153        try:\n154            degrees = float(degrees)\n155        except:\n156            return image\n157    if not isinstance(clockwise, bool):\n158        clockwise = False\n159    if not isinstance(expand, bool):\n160        expand = False\n161    # Invert degrees if we rotate clockwise.\n162    degrees = -degrees if clockwise else degrees\n163    return image.rotate(degrees, expand=expand)\n164\n165\n166def sharpen(image:Image.Image) -&gt; Image.Image:\n167    \"\"\"#Apply a sharpen filter to the image\n168    \n169    **Parameters:**\n170    - image (Image): PIL image object\n171\n172    **Returns**:\n173    PIL Image object\n174    \"\"\"\n175    return image.filter(filter=ImageFilter.SHARPEN)\n176\n177\n178ALLOWED_OPERATIONS = {\n179    \"blur\": blur,\n180    \"greyscale\": greyscale,\n181    \"posterize\": posterize,\n182    \"resize\": resize,\n183    \"rotate\": rotate,\n184    \"sharpen\": sharpen\n185}\n186\"\"\"@private\"\"\"\n</pre> def blur(image: PIL.Image.Image) -&gt; PIL.Image.Image: View Source <pre>29def blur(image:Image.Image) -&gt; Image.Image:\n30    \"\"\"#Apply a blur filter to the image\n31    \n32    **Parameters:**\n33    - image (Image): PIL image object\n34\n35    **Returns**:\n36    PIL Image object\n37    \"\"\"\n38    return image.filter(filter=ImageFilter.BLUR)\n</pre> def greyscale(image: PIL.Image.Image) -&gt; PIL.Image.Image: View Source <pre>41def greyscale(image:Image.Image) -&gt; Image.Image:\n42    \"\"\"#Apply a greyscale filter to the image\n43    \n44    **Parameters:**\n45    - image (Image): PIL image object\n46\n47    **Returns**:\n48    PIL Image object\n49    \"\"\"\n50    return ImageOps.grayscale(image)\n</pre> def posterize(image: PIL.Image.Image, intensity=2) -&gt; PIL.Image.Image: View Source <pre>53def posterize(image:Image.Image, intensity=2) -&gt; Image.Image:\n54    \"\"\"#Apply a posterize filter to the image\n55    \n56    **Parameters:**\n57    - image (Image): PIL image object\n58    - intensity: How strong the posterize effect should be. \n59    Must be an integer between 1 (strongest) and 8 (weakest).\n60\n61    **Description:**\n62    This filter will reduce the colors of the image, creating a poster-like effect.\n63\n64    **Returns**:\n65    PIL Image object\n66    \"\"\"\n67    if isinstance(intensity, str) or isinstance(intensity, float):\n68        try:\n69            intensity = int(intensity)\n70        except:\n71            intensity = 2\n72    if intensity &lt; 1 or intensity &gt; 8:\n73        intensity = 2\n74    return ImageOps.posterize(image, intensity)\n</pre> def resize( image: PIL.Image.Image, width: str = None, height: str = None) -&gt; PIL.Image.Image: View Source <pre> 77def resize(image:Image.Image, width:str=None, height:str=None) -&gt; Image.Image:\n 78    \"\"\"#Resize the image to the provided dimensions\n 79    \n 80    **Parameters:**\n 81    - image (Image): PIL image object\n 82    - width (str): Width to which the image should be resized\n 83    - height (str): Height to which the image should be resized\n 84\n 85    **Description:**  \n 86    If both width and height are given, the image will be resized \n 87    regardless of aspect ratio.  \n 88    If either width or height are given, the image will be scaled to \n 89    that dimension and aspect ratio will be maintained.  \n 90    If the given dimension(s) are bigger than the original image, or \n 91    neither width nor height are provided, the original image will be \n 92    returned without resizing.\n 93\n 94    **Returns**:\n 95    PIL Image object\n 96    \"\"\"\n 97    # If no dimensions were provided, return the original image.\n 98    if not width and not height:\n 99        return image\n100    \n101    # Get original image dimensions\n102    orig_w, orig_h = image.size\n103\n104    if width:\n105        width, unit = parse_dimension(width)\n106        if unit == Unit.PERCENT:\n107            width = int(orig_w * width / 100)\n108\n109    if height:\n110        height, unit = parse_dimension(height)\n111        if unit == Unit.PERCENT:\n112            height = int(orig_h * height / 100)\n113\n114    # Scale the dimension that was not provided\n115    if not height:\n116        # Calculate by how much the image scales down\n117        scale = width / orig_w\n118        # Scale the height accordingly\n119        height = int(orig_h * scale)\n120    elif not width:\n121        scale = height / orig_h\n122        width = int(orig_w * scale)\n123\n124    # Make sure the given dimensions are greater than 0 and don't exceed the original image.\n125    if width &lt;= 0 or height &lt;= 0 or width &gt; orig_w or height &gt; orig_h:\n126        return image\n127    \n128    return image.resize((width, height))\n</pre> def rotate( image: PIL.Image.Image, degrees, expand: bool = True, clockwise: bool = False) -&gt; PIL.Image.Image: View Source <pre>131def rotate(image:Image.Image, degrees, expand:bool=True, clockwise:bool=False) -&gt; Image.Image:\n132    \"\"\"#Rotate the image by the provided degrees\n133    \n134    **Parameters:**\n135    - image (Image): PIL image object\n136    - degrees (int|float|str): Amount of degrees by which to rotate the image\n137    - expand (bool): Whether the image dimensions should expand so that the \n138    resulting image contains all of the original image. If set to False, the \n139    image will remain the same size and parts that would be \"outside\" the image \n140    due to roation will be cut. For rotating by 90 and 270 degrees, leave this \n141    setting set to True, since this will allow width and height of the image to \n142    switch without producing a border\n143    - clockwise (bool): Set to True for clockwise rotation. Per default, rotation \n144    is counter-clockwise\n145\n146    **Description:**  \n147    Rotate the image counter-clockwise by the provided degrees.\n148\n149    **Returns**:\n150    PIL Image object\n151    \"\"\"\n152    # If we get a string, try to convert to float\n153    if isinstance(degrees, str):\n154        try:\n155            degrees = float(degrees)\n156        except:\n157            return image\n158    if not isinstance(clockwise, bool):\n159        clockwise = False\n160    if not isinstance(expand, bool):\n161        expand = False\n162    # Invert degrees if we rotate clockwise.\n163    degrees = -degrees if clockwise else degrees\n164    return image.rotate(degrees, expand=expand)\n</pre> def sharpen(image: PIL.Image.Image) -&gt; PIL.Image.Image: View Source <pre>167def sharpen(image:Image.Image) -&gt; Image.Image:\n168    \"\"\"#Apply a sharpen filter to the image\n169    \n170    **Parameters:**\n171    - image (Image): PIL image object\n172\n173    **Returns**:\n174    PIL Image object\n175    \"\"\"\n176    return image.filter(filter=ImageFilter.SHARPEN)\n</pre>"},{"location":"api/operations/#apply-a-blur-filter-to-the-image","title":"Apply a blur filter to the image","text":"<p>Parameters:</p> <ul> <li>image (Image): PIL image object</li> </ul> <p>Returns: PIL Image object</p>"},{"location":"api/operations/#apply-a-greyscale-filter-to-the-image","title":"Apply a greyscale filter to the image","text":"<p>Parameters:</p> <ul> <li>image (Image): PIL image object</li> </ul> <p>Returns: PIL Image object</p>"},{"location":"api/operations/#apply-a-posterize-filter-to-the-image","title":"Apply a posterize filter to the image","text":"<p>Parameters:</p> <ul> <li>image (Image): PIL image object</li> <li>intensity: How strong the posterize effect should be.  Must be an integer between 1 (strongest) and 8 (weakest).</li> </ul> <p>Description: This filter will reduce the colors of the image, creating a poster-like effect.</p> <p>Returns: PIL Image object</p>"},{"location":"api/operations/#resize-the-image-to-the-provided-dimensions","title":"Resize the image to the provided dimensions","text":"<p>Parameters:</p> <ul> <li>image (Image): PIL image object</li> <li>width (str): Width to which the image should be resized</li> <li>height (str): Height to which the image should be resized</li> </ul> <p>Description:  If both width and height are given, the image will be resized  regardless of aspect ratio.  If either width or height are given, the image will be scaled to  that dimension and aspect ratio will be maintained.  If the given dimension(s) are bigger than the original image, or  neither width nor height are provided, the original image will be  returned without resizing.</p> <p>Returns: PIL Image object</p>"},{"location":"api/operations/#rotate-the-image-by-the-provided-degrees","title":"Rotate the image by the provided degrees","text":"<p>Parameters:</p> <ul> <li>image (Image): PIL image object</li> <li>degrees (int|float|str): Amount of degrees by which to rotate the image</li> <li>expand (bool): Whether the image dimensions should expand so that the  resulting image contains all of the original image. If set to False, the  image will remain the same size and parts that would be \"outside\" the image  due to roation will be cut. For rotating by 90 and 270 degrees, leave this  setting set to True, since this will allow width and height of the image to  switch without producing a border</li> <li>clockwise (bool): Set to True for clockwise rotation. Per default, rotation  is counter-clockwise</li> </ul> <p>Description:  Rotate the image counter-clockwise by the provided degrees.</p> <p>Returns: PIL Image object</p>"},{"location":"api/operations/#apply-a-sharpen-filter-to-the-image","title":"Apply a sharpen filter to the image","text":"<p>Parameters:</p> <ul> <li>image (Image): PIL image object</li> </ul> <p>Returns: PIL Image object</p>"}]}